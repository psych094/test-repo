Book: Pro Git
<<<<	PART 1    >>>>
Initial setup when running git:

Git contains 2 configuration files. The "git config" command is used to set the values
in the config files.
In the Unix environment:
1) /etc/gitconfig: Holds values for all users and repositories in the system.
These values are/have to be defined. The "--system" switch has to be passed to make
changes to the system config file.
2) ~/.gitconfig or ~/.config/git/config: Holds values specifically for the user the config file
is present in. The "--global" switch has to be passed to make changes to the user config
file.
3) config inside the repo directory (./.git/config): Holds values specifically for the repo
being worked on. No switches have to passed in order to make changes to the repository
config file.

Each consequtive level has a higher precedence over the previous level.
The level of precedence is 3 > 2 > 1 where level 3 has a higher precedence to
being used over level 2 and level 2 has a higher precedence over level 1.

On the Windows system:
1) System config file: The equivalent of /etc/config in Windows is located in
"C:\Documents and Settings\All Users\Application Data\Git\config" (Windows XP)or
"C:\ProgramData\Git\config" (Windows Vista and later).
2) User config file: The equivalent of .gitconfig or .config/git/config is located in
the user home directory, usually C:\Users\$USER.
3) The repository config file: Located as the same as the Unix environment. .git/config
inside the repository directory.


Specify a username to use with git in the system:
$ git config --global user.name "Username"

Specify an email address to use with git in the system:
$ git config --global user.email username@domainName.domainSuffix

Choosing a text editor for git messages in an Unix environment:
$ git config --global core.editor vim
$ git config --global core.editor nano


Choosing Notepad++ as default text editor in Windows.
1) Using a 32-bit editor in a 32-bit system or 64-bit editor in a 64-bit system:
$ git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' \
-multiInst -nosession"
2) Using a 32-bit editor in a 64-bit system:
$ git config --global core.editor "'C:/Program Files(x86)/Notepad++/notepad++.exe' \
-multiInst -nosession"

List out the config file variables
$ git config --list

Some of the output from the configuration listing will be shown more than once. Git reads
the same values from the three available config files. In such cases, git uses the last
value it reads from the three config files when making commits. The value used still
follows the order of precedence.


Gettings help for commands:
$ git help <verb>
$ man git-<verb>
Verb here being the git actions. Ex. "git config", config here being the verb.

Examples:
Help of git action "config":
$ git help config
$ man git-config

Both the above commands open the manual page (manpage) for the git actions. Usually the
complete manual pages aren't necessary. Simply using the "--help" or "-h" switch with the
command would display shorter details of the command actions.
$ git config -h
$ git config --help (In the Windows system, the manpage is still opened)


<<<<	PART 2	>>>>
Working with repositories

Initializing a repository:
A project not under version control by git first needs to be initialized. The git bash
needs to be opened in the directory of the project and the following command needs to be
executed:
$ git init
The above command creates a directory ".git" in the project directory. It contains the
necessary files required for the Version Control System (VCS) to create a repository.
Otherwise known as a repository skeleton. This directory contains nothing of the project
files, for the time being. For git to start keeping track of changes, file tracking needs
and an initial commit needs to be done. This can be accomplished using the following
commands:
$ git add
$ git commit

Examples:
Adding a file to the repository.
$ git add *.txt
The command will add all text files inside the current directory to be tracked.
$ git commit -m 'Initial project version'
Will commit the files into the repository with the details of the commit using the "-m"
switch and the string inside the quotes after the switch is the message.


Cloning an existing repository:
If there is a repository that already exist, there is no need to initialize a directory.
The "git clone" command can be used to obtain the copy of the repository. Git receives
the full copy almost all the data the server holds. Every version of the files, the history
of the project is copied when the clone command is run.
Example:
$ git clone https://github.com/libgit2/libgit2
This command will create a directory with the name libgit2, initialize a .git directory and
receive all the data for the repository.
But if the repository is to be stored in a directory that already exists, the following
command can be run instead:
$ get clone https://github.com/libgit2/libgit2 myfolder
This will clone and store the repository data inside the directory called "myfolder".

Git uses multiple protocols for cloning repositories. The preceding examples used the
https:// protocol. There are also the git:// and user@server:path/to/repo.git which uses
the SSH transfer protocol.


Recording changes to the repository:
The files in a git repository are in two states known as tracked or untracked.
Tracked files are files that were in the last snapshot. These can be unmodified, modified
or staged files. These are the files which are already in the repository and that git
knows about.
Untracked files are other files that were not in the last snapshot and are not in the
staged by git.
After cloning a repository, all the files will be tracked and modified. If there are files
already in there. When the files are edited, they are modified. Because it is changed
since the last commit. As working with git, the modified files are selected for the staging
area and then commit the staged changes. This cycle repeats all the time.

Checking the status of files:
The command used to check the status of files is:
$ git status
Running this command will list the untracked, modified and files that are staged or if
there are non of the specified specified, it will notify that the directory is clean.

When checked with no files changes made:
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean

The command also tells which branch you're on and that it has not diverged from the same
branch on the server.
When a file is added, lets name it gitCommands.txt (this file), running the status command
will display:
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    gitCommands.txt

nothing added to commit but untracked files present (use "git add" to track)

The readme.txt file is untracked because it's under the "Untracked files" heading in the
status output. Untracked files are files that were not present in the last commit of the
repository. Git will not include it in further commits until specified to do. This is so
that files that are not neede to be included are not added into the commits. Although there
are methods of telling Git to ignore certain file types or files with a certain name
pattern.

Tracking new files:
To track new files, the "git add" command is used.
Adding the gitCommands.txt file:
$ git add gitCommands.txt
Now running the status command again:
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:	gitCommands.txt

The new file gitCommands.txt is staged because it's under the "Changes to be committed"
heading. If committed, the version of the file when the git add was run is what will be
added into the project history.
The "git add" command takes a path name for either a file or a directory, if it's a
directory, the command adds all the files in the specified directory.

Staging Modified files:
After making changes to the current file, which is tracked, running the "git status" will
result in the output as:
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   gitCommands.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   gitCommands.txt
The gitCommands.txt file appears under the "Changes to be committed" and "Changes not
staged for commit" headings. The second heading are for files that are tracked that has
been modified in the working directory but has not been staged for commit, although I
haven't really committed the file to the repository yet. To stage it, "git add" is used.
The add command is a multipurpose command, it is used for adding new files, to stage files
and other things like marking merge-conflicted files as resolved. Easier understood to
think of it as the command to add to the next commit.
Running git add to the changed file:
$ git add gitCommands.txt
$ git status
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   gitCommands.txt
There is only the one file under the "Changes to be committed" heading. There was just the
one file that was added to the stage and then further modified, so there will only be one
file name displayed when staged again. If it were a different file that was modified and
then staged, there would be two file names under the "Changes to be committed" heading. It
would look something like this:
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   gitCommands.txt
		modified:	index.html

In this example, the second file was named index.html assuming the index.html file already
was a part of the previous commits. If it itself was a new file, instead of "modified", it
would be categorized as "new file" just like the gitCommands.txt file. I still have not
committed it to the repository. Guess I'll just do it now. :P

Short status:
The "git status" command contains too many words! Use the short form:
$ git status -s
$ git status -short
Not exactly a short command -_- :P
Running the command displays:
$ git status -s
AM gitCommands.txt
The two letters "AM" indicate the status of the file. Each letter is actually a column.
In this example, the left column contains the letter "A" and the right column contains the
letter "M". The A indicates that new files have been added to the staging area. The letter
"M" indicates the file has been modified. The left column tells the status of the staging
area and the right column tells the status of the files in the working directory.

An M in the left column would mean a tracked file has been modified?
Yep. Modified tracked file.

Ignoring files (Already know such a feature exists :P):
There are files that need to be ignored and not added into the commits or completely
ignored by Git itself. These files may be log files or files produced by a build system.
These files can be ignored by Git by creating a list of patterns to match them in a file
named ".gitignore".
In an existing project, inside the .gitignore file could contain the following:
$ cat .gitignore
*.[oa]
*~
The first pattern tells to ignore any files ending with ".o" or ".a". These are object or
archive files created from compiling source codes. The second pattern are of file names
ending with a tilde (~). Filenames ending with a tilde are usually the temp files text
editors such as Emacs use to mark temporary files.
Other file formats that may be present are log, tmp or pid directory, automatically generated
documentation and list goes on and on.
Good idea to set up a .gitignore file in a new repository before committing files.
-_- Now the writer talks about it -_-

Rules for patterns inside .gitignore are:
- Blank lines or lines starting with # are ignored. (No kidding about blank lines -_-)
- Standard glob patterns work, and will be applied recursively throughout the entire
working tree. (Hm-hmm)
- You can start patterns with a forward slash (/) to avoid recursivity. (Huh?)
- You can end patterns with a forward slash (/) to specify a directory.
- You can negate a pattern by starting it with an exclamation point (!). What?! o.O

Glob patterns: Simplified regular expressions (Ugh!) that shells (Yay!) use.
- An asterisk matches zero or more characters.
- [abc] matches any (one) character inside the square brackets.
- A question mark (?) matches a single character.
- Brackets enclosing characters separated by a hyphen match any characters between them.
[0-9] would match any (one) character from 0 to 9.
[a-z] any lowercase letters from a to z.
[A-Z], any uppercase letters from A to Z.
- Two asterisks to match nested directories.
a/**/z would match a file named z in any sub-directory inside a. (Okay. This was easy to
understand.)

Tip: GComprehensive list of .gitignore available in GitHub at
https://github.com/github/gitignore. Gotta have a look.

Viewing staged and unstaged changes:
Using the "git status" only displays what files are untracked, modified and staged. It does
not display the differences between the modified files and the committed files. Simply
running the following command will display the changes made:
$ git diff

What "git diff" shows:
1) Modified files not yet staged.
2) Staged files not yet committed.
"git status" displays the files whereas "git diff" displays the exact lines that have been
changed.

Any changes made to a file and HAS NOT been staged, a difference will be shown between the
modified file and the last committed version of the file.

Using this file gitCommands.txt, let's see the changes made from the last commit and the
last time I saved the file:
$ git diff
diff --git a/gitCommands.txt b/gitCommands.txt
index bbb37ac..a733543 100644
--- a/gitCommands.txt
+++ b/gitCommands.txt
@@ -291,3 +291,15 @@ understand.)
 Tip: GComprehensive list of .gitignore available in GitHub at
 https://github.com/github/gitignore. Gotta have a look.

+Viewing staged and unstaged changes:
+Using the "git status" only displays what files are untracked, modified and staged. It does
+not display the differences between the modified files and the committed files. Simply
+running the following command will display the changes made:
+$ git diff
+
+What "git diff" shows:
+1) Modified files not yet staged.
+2) Staged files not yet committed.
+"git status" displays the files whereas "git diff" displays the exact lines that have been


This is the output of the difference between the unstaged modified file and my last commit
file. The "+" sign indicates new lines and a "-" would indicate deletions. There are an
addition of 10 lines.
Simply "git diff" will display differences between the unstaged modified files and the last
committed files. To see the differences between the files that have been staged for the
next commit, the following command will need to be run:
$ git diff --staged
The output of the command should be the same as the normal "git diff" command. Gotta make
a todo file to add an example here for this situation.
Alright. Got an example going using the todo file instead. Here it is:
$ git diff --staged
diff --git a/todo b/todo
index b007070..f14b37f 100644
--- a/todo
+++ b/todo
@@ -1 +1 @@
-git diff --staged example
\ No newline at end of file
+Add in an example for the git diff --staged command.

The \ No newline at end of file was because the file was just one line that didn't end
with the press of the 'Enter' key.
The output is pretty much the same with the exception in this example, there is a deletion
in this difference.

Note: git diff doesn't show all changes made since last commit. Only the unstaged changes.
I did run the git diff after staging (while I still didn't understand the diff command),
that explains it.
If a file that has been modified and staged, then further modified. "git diff" will display
the changes between the staged and unstaged modified files.
Another form of the "git diff --staged" command is:
$ git diff --cached
--cached and --staged display the same output. That is to display the staged modified file
differences.
Note: "git diff" will be used in various ways. Grahical or external diff viewing programs
are available to use. Running "git difftool" will display the diffs in software like emerge,
vimdiff or others, including commercial ones. Running "git difftool --tool-help" will
display what is available in the current system.

Committing your changes (What have I been doing then?):
After getting your staging area set as desired. Comes the time to commit the changes. Any
file that is created or further editted will not be committed unless added to the staging
area, Git will see it as modified files. Remember to "git add" the file. The simplest
command to commit the changes is:
$ git commit
Running the command will open the system default text editor or the preferred on installed
with Git when installing for Windows.
The choice of editor can be changed using the "git config --global" command.
When the editor opens, the default commit message consists of an empty line, the first
line, and the output of the "git status" command commented out. In the first line, here is
where the commit message needs to be typed in. Type in a message about what the commit is
about. The "git status" output can be uncommented to add extra details about the files in
the commit. Furthermore, for an explicit reminder, the commit command can be passed with
the "-v" option to also include the "git diff" output, displaying the differences in the
new files, to be commited. This information by default is not commented out. I just ran the 
command and editted the "git diff" output to only display the first two lines and the
differences. Just realized instead of having to go through the trouble of deletion of other
details, I could have just commented them out. Ugh!
The command with the diff output in the commit message:
$ git commit -v
When writing small commit messages, alternatively, the "-m" flag can be used to include the
message within the commit command, as follows:
$ git commit -m "Commit message here"
This is good for small commit messages that don't require much details. Such as, addition
of a new file or a spelling mistake in comment or code.

After committing, there will be an output on the screen. It tells which branch the commit
has been added to, the SHA-1 checksum of the commit, how many files were changed and
how many lines were added or removed. Committing files adds the data and changes to the
history of the project as a snapshot. It creates a snapshot everytime there is a commit.
This snapshot can be used to revert changes made or to compare for later use.

Skipping the staging area (Immediately commmit changes):
Although the staging area is useful for committing specific files. Sometimes when needing
to commit every file in the working directory, the commit command has an option/flag for
that specific task:
$ git commit -a
Simply adding the "-a" flag adds all files in the working directory to the commit.

Removing files:
To remove a file from Git, it has to be removed from the list of tracked files. More
precisely, it has to be removed from the staging area and then committed. The "git rm"
command does that and also removes the file from the working directory so that Git doesn't
see it as an untracked file. Simply deleting the file will cause it to be shown in the
"Changes not staged for commit" area , basically Git sees it as an unstaged file. Although
it's actually not there. To remove a file from the repository and the working directory
tree, the command needs to be:
$ git rm <file>
This command also stages the deletion of the file for the commit.
If a file that has been modified and staged, the "git rm" command will also have to be used
with the "-f" option. This is suppose to be a safety feature to prevent the deletion of
data that hasn't been saved in a snapshot of the repository.
Another useful thing is to keep the files stored in the computer but to remove the files
from the staging area. Useful if a file that has not been added into the ".gitignore" file
and has been staged for the next commit. The command is:
$ git rm --cached <file>
Files, directories and file-glob patterns can be passed to "git rm".
For example:
$ git rm log/\*.log
To remove all .log files inside the log/ directory from the staging area. The backslash (\)
before the asterisk (*) was needed since Git does it's own filename expansion in addition
to the shell's filename expansion.
If there is the need to remove files in the current working directory:
$ git rm \*~
This will remove any file ending with a tilde (~).

NOTE: If the shells expansion is passed into the "git rm" command, the "git rm" command
would be receiving the entire list of files when the shell's filename expansion is used.
It would be like running the "git rm" command as:
$ git rm <file1> <file2> <file3> <file4> <file5> ... etc
So yeah. The backslash is needed to let Git do it's own thing when it's capable of.


Moving files:
Unlike other VCS systems, Git doesn't explicitly track file movement. If a file is renamed
in Git, there is no metadata stored inside Git that the file has been renamed.
Git has a "git mv" command to move or rename a file:
$ git mv <from_somewhere> <to_somewhere>
It works as it should. Running the "git status" command displays that the file has been
renamed and it's been staged.
It is also the same as running:
$ mv <from_somewhere> <to_somewhere>
$ git rm <from_somewhere>
$ git add <to_somewhere>
Here in the second and third command, <from_somewhere> and <to_somewhere> being the names
of the files used in the first command. Running these three commands have the same effect
as running the "git mv". The convenience being, only on command is needed when using the
command available in Git.


Viewing the commit history:
To look back to see what has happened with the repository. The most basic tool for doing
this is:
$ git log
By default, the output are all the commits starting with the recent to the first commit
messages. The output contains the SHA-1 checksum, author's name and email, the date written
and the commit message.
Many options are available with the log command to display the repository logs in various
ways.
Some of the most popular ones covered in the book.
$ git log -p
$ git log --patch
Displays the changes made in each commit.

$ git log -3
"3" here being the number of the logs to display of command output.

$ git log --stat
Displays the a brief information about the changes of the commits.

$ git log --pretty=oneline
Prints the output in one line.

$ git log --pretty=short
$ git log --pretty=full
$ git log --pretty=fuller
Displays almost the same out as the "--pretty=oneline" with less or more info.

$ git log --pretty=format:"%h - %an, %ar : %s"
Displays the log output in a specific format since the predefined formats could change with
and update to Git.
Options for the format options, such as the "%h" and others, are:
|---------------------------------------------------------|
|                     format options                      |
|----------|----------------------------------------------|
|  Option  | Description of Output                        |
|    %H    | Commit hash                                  |
|    %h    | Abbreviated commit hash                      |
|    %T    | Tree hash                                    |
|    %t    | Abbreviated tree hash                        |
|    %P    | Parent hashes                                |
|    %p    | Abbreviated parent hashes                    |
|   %an    | Author name                                  |
|   %ae    | Author email                                 |
|   %ad    | Author date (for of date uses --date=option) |
|   %ar    | Author date, relative                        |
|   %cn    | Comitter name                                |
|   %ce    | Comitter email                               |
|   %cd    | Comitter date                                |
|   %cr    | Comitter date, relative                      |
|    %s    | Subject                                      |
|----------|----------------------------------------------|

Difference between author and committer:
Author is the person who wrote the work. The committer is the person who committed the work.
If a contributer sends a patch to a work and the developer applies the patch to the
repository, both the contributer and the developer get the credit. To be further covered in
another section labeled "Distributed Git".
"oneline" and "format" options are useful with the "--graph" option. Output is an ASCII
graph that displays the branch and merge history.
The output will become interesting (really now?) in the next chapter when going through
branching and merging (I'll take your word for it).

These were only simple output-formatting to "git log" (Seriously? -_- ). And there's more?
There's always more than meets the eye, huh? Common options of "git log" lists the options
covered so far (What about the other options?). Oh, as well as other common formatting
options that may be useful (May be?) that change the output of the log command.
|-------------------------------------------------------------------------------------------|
|                                      Common options                                       |
|------------------|------------------------------------------------------------------------|
|      Option      |                               Description                              |
|------------------|------------------------------------------------------------------------|
|        -p        | Show the patch introduced with each commit.                            |
|     --stat       | Show statistics for files modified in each commit.                     |
|   --shortstat    | Display only the changed/insertions/deletions line from the --stat     |
|                  | command.                                                               |
|   --name-only    | Show the list of files modified after the commit information.          |
|  --name-status   | Show the list of files affected with the added/modified/deleted        |
|                  | information as well.                                                   |
| --abbrev-commit  | Show only the first few characters of the SHA-1 checksum instead of    |
|                  | all 40.                                                                |
| --relative-date  | Display the date in a relative format (for example, "2 weeks ago")     |
|                  | instead of using the full date format.                                 |
|    --graph       | Display an ASCII graph of the branch and merge history beside the      |
|                  | log output.                                                            |
|    --pretty      | Show commits in an alternative format. Options include oneline, short, |
|                  | full, fuller, and format (Where you specify your own format).          |
|    --oneline     | Shorthand for --pretty=oneline abbrev-commit used together.            |
|------------------|------------------------------------------------------------------------|


Limiting log output:
There is output-formatting, as already done. There is also log output limiting. Okay.
"git log" takes a number of useful limiting options that only displays a subset of commits.
One option already done is the -<n> option. The <n> is an integer. There are more options.
Time-limiting options such as "--since" and "--until" are useful. For example:
$ git log --since=2.weeks
Displays the commits made in the last two weeks. This works with lots of formatting.
Date format can be specified like "2008-01-15" or a relative date such as "2 years 1 day
3 minutes ago" (Okay. Cool, cool).
The commits can also be filtered to match some criteria. The "--author" option allows you
to filter on a specific author and the "--grep" option lets you search for keywords in the
commit messages.
Note: More than one instance can be specified, like using both the "--author" and "--grep"
search criteria which will limit the commit outputs to commits that match any of the
"--author" patterns and the "--grep" patterns (I wonder other criteria are there, just using
these two when explaining the concept -_- ). However, adding the "--all-match" option limits
the output to the commits that match the "--grep" patterns.
Oh, look! There is a table coming up! Yay -_-

Another "really" helpful filter (I get it now, they're all helpful) is the "-S" option,
casually referred as Git's "pickaxe" option. Okay. Whatever. It takes a string and shows
only the commits that changed the number of occurrences of that string. How the fuck am I
suppose to paraphrase that -_- What the fuck is that even suppose to mean?!
Goody. There is an example:
$ git log -S function_name
If you wanted to find the last commit that added or removed a reference to a specific
function. Still got no clue on how that works...
Hmm. Probably looks at the filename or the file diffs? Whatever.

The last really useful option (Now comes the last?) as a filter is to use the path. If
specified a directory or file name, the log outputs are limited to only those files in the
commits. Always is the last option and is preceded with a double dash (--) to separate the
paths from the options.
|------------------------------------------------------------------------------------------|
|                                   Output Limit Options                                   |
|------------------------------------------------------------------------------------------|
|      Option       | Description                                                          |
|-------------------|----------------------------------------------------------------------|
|       -<n>        | Show only the last n commits.                                        |
| --since, --after  | Limit the commits to those made after the specified date.            |
| --until, --before | Limit the commits to those made before the specified date.           |
|      --author     | Only show commits on which the author entry matches the specified    |
|                   | string.                                                              |
|   --committer     | Only show commits in which the committer entry matches the specified |
|                   | string.                                                              |
|      --grep       | Only show commits with a commit message containing the string.       |
|        -S         | Only show commits adding or removing code matching the string.       |
|-------------------|----------------------------------------------------------------------|

Example (Useful since it contains the path thing):
$ git log --pretty="%h - %s" --author-gitster --since="2008-10-01" --before="2008-11-01" \
--no-merges -- t/
Output from some repository from the book examples.
Whatever. From almost 40,000 commits, there were just 6 lines of output.

Tip: Preventing the display of merge commits. Depending on the workflow in the repository,
it's possible that that a sizable percentage of the commits in your history are just merge
commits which typically aren't very informative. To prevent the display of merge commits
cluttering up your log history, simply add the log option "--no-merge".


Undoing things:
